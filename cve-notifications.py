import tkinter as tk
from tkinter import ttk
from PIL import Image, ImageTk
import urllib.request
import gzip
import json
import io
import os
import requests

SEVERITY_RANGES = {
    "All": (0.0, 10.0),
    "Low": (0.1, 3.9),
    "Medium": (4.0, 6.9),
    "High": (7.0, 8.9),
    "Critical": (9.0, 10.0)
}

def get_severity_color(score):
    if score is None:
        return "gray"
    elif score >= 9.0:
        return "red"
    elif score >= 7.0:
        return "orange"
    elif score >= 4.0:
        return "yellow"
    else:
        return "green"

def fetch_recent_cves():
    url = "https://nvd.nist.gov/feeds/json/cve/1.1/nvdcve-1.1-recent.json.gz"
    try:
        with urllib.request.urlopen(url) as response:
            with gzip.GzipFile(fileobj=io.BytesIO(response.read())) as f:
                cve_data = json.load(f)
        return cve_data.get("CVE_Items", [])
    except Exception as e:
        print("Error fetching CVEs:", e)
        return []

def load_microsoft_cves():
        url = "https://api.msrc.microsoft.com/sug/v2.0/en-US/vulnerability"
        headers = {
            "Accept": "application/json",
            "User-Agent": "Mozilla/5.0"
        }
    
        try:
            print("[*] Fetching Microsoft CVE data...")
            response = requests.get(url, headers=headers, timeout=20)
            response.raise_for_status()
            data = response.json()
            items = []
    
            for entry in data.get("value", []):
                cve_id = entry.get("cveNumber", "")
                description = entry.get("title", "No description provided")
                published = entry.get("publicDate", "N/A")
                severity = entry.get("cvssScore", 5.0)  # Default score
    
                item = {
                    "cve": {
                        "CVE_data_meta": {"ID": cve_id},
                        "description": {
                            "description_data": [{"value": description}]
                        }
                    },
                    "publishedDate": published,
                    "impact": {
                        "baseMetricV3": {
                            "cvssV3": {
                                "baseScore": float(severity)
                            }
                        }
                    },
                    "source": "Microsoft"
                }
    
                items.append(item)
    
            print(f"[âœ”] Parsed {len(items)} Microsoft CVEs")
            return items
        except Exception as e:
            print("[!] Microsoft CVE fetch failed:", e)
            return []

def load_cisa_cves():
    cisa_path = "/home/sandbender/PyScripts/VulnScan/cisa_known_exploited_cves.json"
    try:
        with open(cisa_path, "r") as f:
            data = json.load(f)
        items = []
        for cve in data.get("vulnerabilities", []):
            if "cveID" not in cve or "shortDescription" not in cve:
                continue
            item = {
                "cve": {
                    "CVE_data_meta": {"ID": cve["cveID"]},
                    "description": {
                        "description_data": [{"value": cve.get("shortDescription", "No description")}]
                    }
                },
                "publishedDate": cve.get("dateAdded", "N/A"),
                "impact": {
                    "baseMetricV3": {
                        "cvssV3": {"baseScore": 8.0}
                    }
                },
                "source": "CISA"
            }
            items.append(item)

        print(f"[âœ”] Loaded {len(items)} CISA CVEs")  # <-- add this
        return items
    except Exception as e:
        print("Error loading CISA CVEs:", e)
        return []

class CVEDashboardApp(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("CVE Dashboard")
        self.geometry("1000x800")
        self.refresh_interval = 600000
        self.selected_severity = tk.StringVar(value="All")
        self.search_keyword = tk.StringVar()

        self.build_ui()
        self.refresh_cves()
        self.auto_refresh()

    def build_ui(self):
        top_frame = tk.Frame(self)
        top_frame.pack(pady=5)

        header_path = "/mnt/data/cyber-header.png"
        if os.path.exists(header_path):
            img = Image.open(header_path).resize((980, 100), Image.ANTIALIAS)
            self.tk_header_image = ImageTk.PhotoImage(img)
            tk.Label(top_frame, image=self.tk_header_image).pack()

        control_frame = tk.Frame(self)
        control_frame.pack(pady=5)

        tk.Label(control_frame, text="Filter by Severity:").pack(side=tk.LEFT, padx=5)
        self.filter_menu = ttk.Combobox(control_frame, textvariable=self.selected_severity, values=list(SEVERITY_RANGES.keys()), state="readonly")
        self.filter_menu.pack(side=tk.LEFT, padx=5)
        self.filter_menu.bind("<<ComboboxSelected>>", lambda e: self.refresh_cves())

        tk.Label(control_frame, text="Search:").pack(side=tk.LEFT, padx=5)
        search_entry = tk.Entry(control_frame, textvariable=self.search_keyword, width=30)
        search_entry.pack(side=tk.LEFT, padx=5)
        search_entry.bind("<Return>", lambda e: self.refresh_cves())

        refresh_button = tk.Button(control_frame, text="ðŸ”„ Refresh Now", command=self.refresh_cves)
        refresh_button.pack(side=tk.LEFT, padx=5)

        self.canvas_frame = tk.Frame(self)
        self.canvas_frame.pack(fill=tk.BOTH, expand=True)

        self.canvas = tk.Canvas(self.canvas_frame)
        self.scrollbar = ttk.Scrollbar(self.canvas_frame, orient=tk.VERTICAL, command=self.canvas.yview)
        self.cve_frame = tk.Frame(self.canvas)

        self.cve_frame.bind("<Configure>", lambda e: self.canvas.configure(scrollregion=self.canvas.bbox("all")))
        self.canvas.create_window((0, 0), window=self.cve_frame, anchor="nw")
        self.canvas.configure(yscrollcommand=self.scrollbar.set)

        self.canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        self.scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    def clear_cves(self):
        for widget in self.cve_frame.winfo_children():
            widget.destroy()

    
    def refresh_cves(self):
        self.clear_cves()
        severity_filter = self.selected_severity.get()
        keyword = self.search_keyword.get().lower()
        min_score, max_score = SEVERITY_RANGES[severity_filter]

        # Combine feeds
        cves = fetch_recent_cves() + load_cisa_cves() + load_microsoft_cves()

        for item in cves:
            cve_id = item['cve']['CVE_data_meta']['ID']
            description = item['cve']['description']['description_data'][0]['value']
            published = item.get('publishedDate', 'N/A')
            score = None
            metrics = item.get("impact", {})
            if "baseMetricV3" in metrics:
                score = metrics["baseMetricV3"]["cvssV3"]["baseScore"]
            elif "baseMetricV2" in metrics:
                score = metrics["baseMetricV2"]["cvssV2"]["baseScore"]

            if score is None or not (min_score <= score <= max_score):
                continue
            if keyword and keyword not in cve_id.lower() and keyword not in description.lower():
                continue

            color = get_severity_color(score)
            outer_frame = tk.Frame(self.cve_frame, bg="white", bd=1, relief="solid")
            summary = tk.Frame(outer_frame, bg=color, padx=5, pady=5)
            summary.pack(fill="x")
            source = item.get("source", "NVD")  # Default to NVD if not specified
            title = f"[{source}] {cve_id} | Published: {published} | CVSS: {score if score else 'N/A'}"
            label = tk.Label(summary, text=title, font=("Helvetica", 10, "bold"), bg=color, anchor="w")
            label.pack(fill="x")

            detail = tk.Label(outer_frame, text=description, wraplength=950, justify="left", bg="white")
            detail.pack(fill="x")
            detail.pack_forget()  # Initially hidden

            def toggle_detail(event, d=detail):
                if d.winfo_ismapped():
                    d.pack_forget()
                else:
                    d.pack(fill="x")

            summary.bind("<Button-1>", toggle_detail)
            label.bind("<Button-1>", toggle_detail)

            outer_frame.pack(fill="x", padx=3, pady=2)

    def auto_refresh(self):
        self.after(self.refresh_interval, self.auto_refresh)
        self.refresh_cves()

CVEDashboardApp().mainloop()